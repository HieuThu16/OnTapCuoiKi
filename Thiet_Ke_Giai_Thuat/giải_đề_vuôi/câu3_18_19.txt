for i ← 0 to n - 2 do
    for j ← i + 1 to n - 1 do
        if a[i] + a[j] = s then
            return true
return false

Trường hợp tốt nhất (best case): O(1) — Nếu cặp đầu tiên đã thỏa mãn điều kiện.

Trường hợp xấu nhất (worst case): O(n²) — Nếu không có cặp nào thỏa mãn (phải duyệt hết).

c/ 
1. sort(a)
2. i ← 0
3. j ← n - 1
4. while i < j do
5.     if a[i] + a[j] = s then return true
6.     else if a[i] + a[j] < s then i ← i + 1
7.     else j ← j - 1
8. return false


Tính độ phức tạp của 1 hàm 
    - Hàm bình thường ( hàm dễ => dễ tính , chỉ có for if else )
    - Đệ quy 
        + có tử mẫu (sẽ xài công thức master ) là cái bên trong của T( )
        + ko thì xài công thức bình thường 

    2 cách tính : Tính bình thường ( xích ma ) + xài công thức master 


    T(n) = 2T(n/2 ) + O(1) 
    a=2   b = 2 
    d = ? 
    
    nếu a > b mũ d => 
    nếu a = b mũ d => 
    nếu a < d mũ d => 


