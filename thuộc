1/ Thuộc quay lui tính tổng = d 
2/ Quay lui nhị phân n bit , 0 liên tiếp  ,1 liên tiếp 

3/ Chia để trị - tìm max 1 mảng 
    Max_num(a, l, r)
1  if l == r
2      return a[l]
3  mid = (l + r) // 2
4  temp1 = Max_num(a, l, mid)
5  temp2 = Max_num(a, mid + 1, r)
6  if temp1 > temp2
7      return temp1
8  else
9      return temp2

4/ horner bình thường + biến đổi để trị 
    bình thường 
        p <- 1 , m <- 1 
        for i <-0 to n-1 do 
            m <- m*x 
            p <- p+ a[i]*m 
        return p 

    chia để trị (a[0...n-1] , x )
        p <- a[n] 
        for i<- 0 to n-1 do 
            p <- p*x + a[i]

5/ Tổng 2 phần tử có tổng bằng s , biến đổi để trị 
     Tổng a[1...n] , ,s 
     sort(a) i <- 0 ,  j <- n-1 
     while(i < j ) do   
        if a[i]+a[j] = s return true 
        else if a[i]+a[j] > s then j <- j - 1 
        else if a[i]+a[j] < s then i <- i + 1 
    return false 

6/ robot nhặt đồng xu 
    Nhặt đồng xu( C[1...n , 1....m])
    
    F[1,1] <- C[1,1]
    for j <-2 to m do 
        F[1,j] <- F[1 , j- 1 ] + C[1,j]
    for i <- 2 to n do 
        F[i,1] <- F[i- 1 , 1 ]  +C[i , 1 ]
    for j <- 2 to m do 
        F[i,j] <- max(F[i-1,j], F[i,j-1]) + C[i,j]
    reutrn F[n,m] 

học nhanh : khởi tạo trên trái cùng -> hàng đầu j -> cột đầu i  -> duyệt tất cả 



7/ Nhị thức 
    Nhị thức ( n, k )
    for i <- 0 to n do 
        C[0][i] <- 1 
        C[i][0] <- 1               
        for i< 1 to k do 
            for j<- 1 to n do 
                c[i][j] <- c[i-1][j-1] + c[i][j-1]
    return c[k][n]


nhanh :có gì có số 0 thì gán 1 -> cũi trái + cũi trên = cũi hiện tại 

8/ Dãy con có tổng lớn nháta 
    max(a[1...n])  
    max_end = max_so_far = 0 
    for i<- 1 to n do 
        max_end = Max(max_end , max_end+a[i])
        max_so_far = Max(max_end , max_so_far)
    return max_so_far

9/ Sắp xếp âm trước dương sau , chia để trị 


    rearrange(a,l,r)
    if l < r 
        if a[l] < 0 
            rearrange(a, l+1 , r )
        else 
            swap(a[l], a[r])
            rearrange(a , l , r -1  )
            

10/ lẻ thì có a 
    Power(a , n ) 
        if ( n=  0 ) return 1 
    x <- power(a , [n/2 ])
    if x%2 == 1 return a*x*x 
    else 
        return x*x 


11/ Khoảng cách gần nhất của 2 số trong 1 mảng  min a[1...n], l ,r 
    if r - l == 1 then 
        return a[r]-a[l]
    else if r-l == 2 then 
        return min(a[l+1]- a[l], a[r]-a[l+1])
    else if     
        m <- (l+r)/2 
        d1 <- min(a, l , m )
        d2 <- min (a , m+1 , r )
        d3 <- trị ( a[m+1]- a[m])
    
    return MIN(d1, d2 , d3 )

Sort 
gọi ra a , 1 , n 



FUNCTION PairSumDivideConquer(a[1..n], s):
    if n < 2:
        return false

    if n == 2:
        return a[0] + a[1] == s

    mid = n // 2
    left = a[0..mid-1]
    right = a[mid..n-1]

    if PairSumDivideConquer(left, s) == true:
        return true
    if PairSumDivideConquer(right, s) == true:
        return true

    // Kiểm tra cặp phần tử từ trái và phải
    for i in 0..len(left)-1:
        for j in 0..len(right)-1:
            if left[i] + right[j] == s:
                return true

    return false
